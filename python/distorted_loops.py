"""Library for adding different families of distortions to audio signals.

  Provides functions to generate sample signals, to add distortions to them
  (in terms of masking, intensity, frequency, timing) and to create sound loops
  with distorted and undistorted copies of the signal.
"""

from typing import Callable, Tuple

import numpy as np
import scipy.signal

from google3.third_party.zimtohrli.python import listening_experiments


def gen_sine_masker(length: int, amount: float = 0.5, freq_hz: float = 1000.,
                    sample_rate: int = 48000) -> np.ndarray:
  """Generates a sine wave masker.

  Args:
    length: Length of masker in samples.
    amount: Amplitude of the sine masker.
    freq_hz: Frequency of the sine in Hz.
    sample_rate: Sample rate of the sine.

  Returns:
    A sine wave masker array.
  """
  return amount * np.sin(
      np.linspace(0, 2 * np.pi * freq_hz * (length - 1) / sample_rate, length))


def gen_white_noise_masker(
    length: int,
    stdev: float = 0.0, *,
    rng: np.random.Generator = None
) -> np.ndarray:
  """Generates white noise masker.

  Args:
    length: Length of masker in samples.
    stdev: Standard deviation of white noise in dB.
    rng: Random number generator for the noise.

  Returns:
    A white noise masker array.
  """
  if rng is None:
    rng = np.random.default_rng()
  stdev_linear = 10 ** (stdev / 20)
  return rng.normal(0.0, stdev_linear, length)


def gen_bandlimited_noise_masker(
    length: int,
    width_hz: float,
    freq_hz: float,
    stdev: float = 0.0,
    rng: np.random.Generator = None
) -> np.ndarray:
  """Generates bandlimited noise masker.

  Args:
    length: Length of masker in samples.
    width_hz: Bandwidth of noise in hz.
    freq_hz: Central frequency of noise in hz.
    stdev: Standard deviation (in db) of white noise, which is filtered to
    produce bandlimited noise.
    rng: Random number generator for the noise

  Returns:
    A bandlimited noise masker array.
  """
  if rng is None:
    rng = np.random.default_rng()
  stdev_linear = 10 ** (stdev / 20)
  white_noise = rng.normal(0.0, stdev_linear, length)

  sos = scipy.signal.butter(
      10, [freq_hz - width_hz / 2, freq_hz + width_hz / 2],
      'bandpass',
      fs=48000,
      output='sos')
  return scipy.signal.sosfilt(sos, white_noise)


def as_distorter(
    fn_gen_masker_from_signal: Callable[..., np.ndarray],
    **distortion_kwargs) -> Callable[[np.ndarray, float], np.ndarray]:
  """Returns a distortion applying function.

  Creates a function that applies the distortion generated by
  `fn_gen_masker_from_signal` to `signal`, scaling the distortion by `strength`.
  Intended use is to apply masker distortions of different `strength` in order
  to specify their JND point.

  Args:
    fn_gen_masker_from_signal: Function that generates an additive distortion.
    **distortion_kwargs: Arguments to pass to fn_gen_masker_from_signal, along
    with len(signal).

  Returns:
    Function that applies additive distortion, generated by
    `fn_gen_masker_from_signal` to `signal`.
  """

  def apply_distortion(signal: np.ndarray, strength: float = 1.):
    """Applies an additive distortion to `signal`.

    Args:
      signal: Array with original signal.
      strength: Scaling factor of additive distortion, for specifying the JND
      point.

    Returns:
      Signal with scaled additive distortion.
    """
    distortion = fn_gen_masker_from_signal(len(signal), **distortion_kwargs)
    return signal + strength * distortion
  return apply_distortion


def intensity_distortion(signal: np.ndarray, amount: float) -> np.ndarray:
  """Creates an intensity distortion by scaling the signal.

  Args:
    signal: Original signal.
    amount: amount of intensity added in dB.

  Returns:
    Signal with modified intensity.
  """
  amount_linear = 10 ** (amount / 20)
  return amount_linear * signal


def timing_distortion(signal: np.ndarray, time_shift_ms: float) -> np.ndarray:
  """Creates a timing distortion by shifting the signal.

  Args:
    signal: Original signal.
    time_shift_ms: Time shift in miliseconds.

  Returns:
    Shifted signal. We keep the duration of the signal equal, so the last
    `time_shift_samples` samples are discarded
  """
  time_shift_samples = int(time_shift_ms * 48000 // 1000)
  return np.pad(signal, [(time_shift_samples, 0)])


def frequency_distortion(signal: np.ndarray, amount: int) -> np.ndarray:
  """Creates a frequency distortion by circularly shifting the signal's fft.

  Args:
    signal: Original signal.
    amount: Frequency samples to shift.

  Returns:
    Signal with shifted fft.
  """
  signal_fft = np.fft.fft(signal)
  shifted_fft = np.pad(signal_fft, [(amount, 0)])[:len(signal_fft)]
  return np.fft.ifft(shifted_fft)


def signal_beep(freq_hz: float, duration: float = 0.1,
                sample_rate_hz: int = 48000) -> np.ndarray:
  """Creates a sine wave signal with specified frequency and duration 0.1 seconds.

  Sample rate is 48 kHz.

  Args:
    freq_hz: Sine wave frequency in hertz.
    duration: Duration of the sine wave in seconds.
    sample_rate_hz: Sample rate of the sine wave in hz.
  Returns:
    Sine wave as an array.
  """

  return 0.5 * np.sin(2 * np.pi * freq_hz *
                      np.arange(sample_rate_hz * duration) / sample_rate_hz)


def distorted_loops(signal: np.ndarray,
                    distortion: Callable[[np.ndarray, float], np.ndarray],
                    amount: float) -> Tuple[np.ndarray, np.ndarray]:
  """Creates loops of the original signal using the ListeningExperiment class.

    Creates an undistorted loop that consists of 8 copies of the signal and a
    distorted loop that consists of 4 copies of the signal, followed by a
    distorted signal, followed by 3 more copies of the signal.

  Args:
    signal: Original signal.
    distortion: Function that adds a specified amount of a distortion to
                `signal`.
    amount: Amount of distortion that `distortion` adds.

  Returns:
    A tuple of the distorted and undistorted loops.
  """
  distorted_signal = distortion(signal, amount)
  le = listening_experiments.ListeningExperiment(
      signal, distorted_signal, 48000)

  no_dist_loop = le.loop(signal, 8, 100)
  dist_loop = le.place_in_sequence(100)

  return no_dist_loop, dist_loop
